### 生产力法则

* 熟悉常用的快捷键，例如浏览器的自动补全www com 可以使用`ctrl+enter`
* 一旦一件东西有了名字，当再次看到它时就会更容易认出来，例如我们给每一种设计模式起了一个具体的名字，就在很容易识别和应用了。

#### 加速法则

提高速度

#### 专注法则

减少环境（物理和心理）的混乱，有效搜索、消除干扰

#### 自动化法则

让计算机为你做更多的事

把一些自己定时执行的任务借助系统或脚本来自动化

我自己每天有哪些工作是定期需要执行的？是否可以自动化？

下班前自动启动编译，自动关机。。。

##### 建立本地缓存

* 对于经常需要到网上查的资料例如API，可以缓存到本地，使用`wget`可以将整个网站镜像到本地

`wget --mirror -w 2 --html-extension --convert-links -P D:\wget_files\exmaple`

`--mirror` 递归跟踪网站链接，下载所有需要的文件。默认只会下载上次镜像之后有更新的文件

`--html-extension`把网站里cgi或php文件转为html

`--convert-links`转换URI链接为本地链接

* cURL可以与网页交互获取内容或抓取资源。使用`-d`采取post请求

`curl -d "name=id&pass=xxx" www.xxx.com/get.cgi`

##### 构建工具

常用的构建工具支持了对文件的批量处理，不用我们自己写脚本，可以用在其他领域自动化实现一些操作。例如使用`Ant`来批量处理一个目录下的所有文件。现在可以使用`Gradle`

每次开机都要用sublime打开4个指定的文件，可以使用批处理自动化实现

##### 使用Selenium浏览网页

作为一个自动化测试工具，可以用它录制脚本执行一些常规操作，以后只需要回放就可以

##### 使用bash处理文本文件

日志文件很多，又大，自己怎么找有用的信息呢？

```bash
#!/bin/bash
for X in $(egrep -o "[A-Z]\w*Exception" log_week.txt | sort | uniq);
do
    echo -n -e "processing $X\t" #输出异常信息到控制台
    grep -c "$X" log_week.txt    #统计这个异常信息在日志文件中出现的次数
done
```

`egrep -o`找出日志文件中出现在Exception之前的文字，对它们排序得到一个去重的列表
`"[A-Z]\w*Exception"`定位异常信息的正则表达式
`| sort`将之前的结果通过管道给sort，生成一个排序后的异常列表
`| uniq`去掉重复信息
`for X in $(...);`对列表中的每一项循环处理

##### 使用Windows Power Shell

开发版本的代号为Monad。PS中的命令(cmdlet)知道代表操作系统构造的对象，如文件、目录、甚至事件查看器。

把2016-12-01之后更新过的文件拷贝到目标目录

`dir | where-object {$_.LastWriteTime -gt "12/1/2006"} | move-item -destination c:\dstDir`

关闭内存超过15M的进程

bash: `ps -el | awk '{ if ($6 > (1024*15)) { print $3}}' | grep -v PID | xargs kill`

ps:`get-process | where { $_.VS -gt 15M} | stop-process`

ps使用.NET实现，因此可以使用标准的.Net类型，如获取String类的所有方法

`get-member -input "String" -membertype method`

##### 命令行Subversion

添加一个目录下所有未加到库里面的文件

`svn st | grep '^\?' | tr '^\?' ' ' | sed 's/[ ]*//' | sed 's/[ ]/\\ /g' | xargs svn add`

`svn st `获取当前目录和子目录中文件的状态，每个文件一行，没有在版本库的以?开头
`grep '^\?' `找出以?开头的行
`tr '^\?' ' ' `把？替换为空格
`sed 's/[ ]*//' `把每行开头的空格去掉
`sed 's/[ ]/\\ /g'`把文件名中的空格前加上\转义字符
`xargs svn add`针对前面处理的结果，逐一调用svn add命令



> 手工执行简单重复的任务会让你变傻，会消耗你的注意力，而注意力是最重要的生产力之源。

修改`bash_profile`创建别名，例如

`alias catout='tail -f /Users/xxx/bin/logs/catalina.out'`

`alias mysql='/usr/local/mysql/bin/mysql -u root'`



##### 时间盒

如果去做自动化工具，可能会出现比计划工作时间长的情况，此时可以使用时间盒的方式控制项目风险：先定好一段时间来探索和了解情况，时间一到就客观的评估是否值得去做这件事。如果时间盒到期后，掌握的信息不够，还可以在增加一个时间盒以便找出更多的信息。但是一般项目经理不太喜欢。

##### 别给牦牛剪毛(yak shaving)

本来做一件小事，但这件小事又依赖其他的事情，结果最后花了大量的时间在处理其他事情，而一开始的事情没有做完。这也是工作量估算出现偏差的原因，如果情况失控，就要即时抽身而出。

#### 规范性

DRY(Don't repeat yourself) 去除重复存在的信息，为每个信息创建唯一的存放处



### 古代哲人

#### 致力本质复杂性，去除附属复杂性

亚里士多德定义的一个逻辑原理是：事物本质性质和附属性质之间的区别。例如有5个单身汗，他们都有棕色眼睛。未婚是他们的本质性质，棕色眼睛是一个附属性质，因此不能推断所有的单身汉都有棕色眼睛。

对于软件的核心功能是本质性质，而实现这个功能的其他相关问题则是附属性质，本质复杂性可以一言蔽之，而附属复杂性常常没完没了。怎样改进可能从根本上让你抛弃一些对整个问题贡献不多却在增加麻烦的东西。你不可能把软件中的附属复杂性统统去掉，但是可以致力于不断减少它们。

难道增加复杂性会降低复杂性吗？几乎不可能。

#### 奥卡姆剃刀原理

如果对于一个现象有好几种解释，那么最简单的解释往往是最正确的。

`80-10-10`定律：80%的需求可以很快完成；下一个10%需求需要花很大的努力才能完成；最后的10%是几乎不可能完成的。为了解决这个问题，发明了Java这些高级通用语言，只要付出足够的努力大多数的工作都可以完成。Java易用却需要大量编码，因此框架出现了，组件增加了，大量的其他框架蜂拥而至。而这些组件构成了附属性质，增加了复杂性。

DSL（领域特定语言）让你在最有价值的地方写代码，而不是琐碎的附属功能上，例如字符串比较这种本应该提供的功能。使用Ruby on Rails大部分是在Rails的DSL部分编码，而不是写Ruby代码。

#### 迪米特法则

只跟最亲密的朋友谈话。任何对象都不需要知道与之交互的那些对象的任何内部细节。

在调用方法时，永远不要用一个以上的“点”。

例如Person对象内有一个Job对象，当Person更换工作时，不应该在Person中直接修改Job的内容，而是调用Job的方法，让Job自己的方法去实现工作切换。

#### 经典软件学说

《人月神话》《程序员修炼之道》《Smalltalk Best Practice Patterns》

反模式`http://c2.com/cgi/wiki?AntiPatternsCatalog`

### 多语言编程

函数式语言如Haskell、OCaml、ErLang、SML，没有状态的概念，更易写出线程安全的代码

使用Groovy可以有效的提高程序的编写效率，即使执行效率低一些，但这点执行效率相对于网络、磁盘读写可以忽略。

