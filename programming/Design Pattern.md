1. 确认软件做的是客户需要的（收集和分析需求）
2. 运用基本的OO原则增加软件的灵活性
3. 努力实现可维护、可重用的设计

为正在试图解决的问题用文字描述清楚，确保你的设计与应用程序想实现的功能一致。可以使用用例图。

任何时候看到重复程序代码，就要找个地方进行封装。

delegation：对象需要执行某些工作时不直接处理该工作，而是要求另一个对象代为处理。每个对象只关注自己的行为，这样一个对象变化，其他委托它的对象不受影响。

低耦合：对象可以从一个应用中取出或更改，然后轻易的应用到另一个应用中，因为它们之间没有紧密联系。各个对象只做自己负责的功能，应用的功能被分散给多个定义良好的对象组合一起工作。

总是通过整理出客户要什么来启动你的项目

一旦完成基本功能，就要重新细化你的设计，让它更灵活

找出应用程序经常变化的部分，试着让它们与其他不改变的地方分开

### 设计原则

* 对修改封闭，对扩展开放
* 单一职责

### 状态模式

#### 定义

状态1---事件1/操作1---状态2

状态1情况下，如果触发了事件1,则状态转移到状态2,然后执行操作1

在分析状态模式时，要先把所有的状态、事件、操作都分析出来，通过状态转换表将状态对各种事件的响应列举出来，避免遗漏。

状态模式可以让一个对象根据自身内部的状态执行不同的操作

状态的转移可以在上下文类中控制也可以在状态内部触发

#### 实现

1. 定义状态接口，接口中定义了所有状态需要响应的事件
2. 定义所有的状态子类，子类中实现事件响应接口
3. 定义一个状态上下文管理类，其中有所有状态的实例，它用来处理状态的转移，上下文管理类将自己的引用传递给各个状态子类
4. 在每个状态子类的事件处理函数中执行需要的操作，以及可能需要调用上下文管理对象接口来转移状态，这样可以避免状态之间相互依赖
5. 定义一个操作接口，用来定义可能的操作行为

状态机的上下文类接收外部的事件，调用相应的事件函数，事件函数再调用状态的事件函数，从而实现当前状态的切换和操作的执行

* 尽量不要在状态中定义任何数据，这样状态可以在多个不同的上下文中复用，只需要把Context类中的状态实例定义为静态的即可